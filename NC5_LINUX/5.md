# 소프트웨어 아키텍처 패턴
1. 계층화 패턴 (Layered pattern)
    1. N-티어 아키텍쳐 패턴이라 부름.
    2. 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다.
        - 일반적인 데스크탑 애플리케이션
        - E-commerce 웹 애플리케이션

2. 클라이언트-서버 패턴(Client-server pattern)
    1. 하나의 서버와 다수의 클라이언트으로 구성.
    2. 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에게 적절한 서비스를 제공한다.
        - 이메일, 문서 공유 및 은행 등의 온라인 애플리케이션

3. 마스터-슬레이브 패턴(Master-slave pattern)
    1. 마스터와 슬레이브 부분으로 구성한다.
    2. 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업을 분산하고, 슬레이브가 반환한 결과값으로 최종 결과값을 계산한다.
        - 데이터베이스 복제에서, 마스터 데이터베이스는 신뢰할 수 있는 데이터 소스로 간주되며 슬레이브 DB와 동기화된다
        - 컴퓨터 시스템에서 버스와 연결된 주변장치

4. 파이프-필터 패턴(Pipe-filter pattern)
    1. 데이트 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다.
    2. 처리 과정은 필터 컴포넌트에서 이루어지며, 처리되는 데이터는 파이프를 통해 흐른다. 
        - 컴파일러, 연속한 필터들은 어휘 분석, 파싱, 의미 분석 그리고 코드 생성을 수행한다.
        - 생불정보학에서의 워크플로우

5. 브로커 패턴(Broker pattern)
    1. 분리된 컴포넌트들로 이루어진 분산 시스템 
    2. 원격 서비스 실행을 통해 서로 상호 작용을 할 수 있다. 브로커 컴포넌트는 컴포넌트간의 통신을 조정하는 역할을 한다.
    3. 서버는 자신의 기능들(서비스 및 특성)을 브로커에 넘겨주며(pulish), 클라이언트가. 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리딕렉션.

6. 피어 투 피어 패턴(Peer-to-tpeer pattern)
    1. 각 컴포넌트를 피어(peers)라고 부른다. 피어는 클라이언트로서 피어에게 서비스를 요청할 수 도있고, 서버로서 각 피어에게 서비스를 제공할 수 있다.
    2. 피어는 클라이언트 또는 서버 혹은 둘 모두로서 동작할 수 있으며, 시간이 지남에 따라 역할이 유동적으로 바뀔 수 있다.
        - 파일 공유 네트워크, 멀티미디어 프로토콜, 독점적 멀티미디어 애플리케이션

7. 이벤트-버스 패턴(Event-bus pattern)
    1. 주로 이벤트를 처리하며 이벤트 소스, 이벤트 리스너, 채널 , 이벤트 버스 가 있다
    2. 소스는 이벤트 버스를 통해 측정 채널로 메시지를 발행하며, 리스너는 특정 채널에서 메시지를 구독한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.
        - 안드로이드 개발, 알림 서비스

8. 



- proxy
- proxy 기능
- reverse proxy
- 서브넷 마스크
- crontab